<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>复古风格国际象棋</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            background: #2c1810 url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%233a2116' fill-opacity='0.2' fill-rule='evenodd'/%3E%3C/svg%3E");
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e8d0b3;
            margin: 0;
            min-height: 100vh;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 800px;
            width: 100%;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 10px;
            padding: 15px;
            background: rgba(90, 50, 30, 0.7);
            border-radius: 10px;
            border: 2px solid #b08d57;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 100%;
        }
        
        .game-header h1 {
            font-size: 2.8rem;
            margin: 0;
            color: #e8d0b3;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.7);
            letter-spacing: 2px;
            font-weight: normal;
        }
        
        .game-header p {
            font-style: italic;
            margin: 10px 0 0;
            font-size: 1.2rem;
            color: #d4b896;
        }
        
        .game-area {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        #chessboard {
            border: 20px solid #5a321e;
            border-radius: 5px;
            box-shadow: 
                0 10px 20px rgba(0, 0, 0, 0.7),
                inset 0 0 30px rgba(0, 0, 0, 0.5);
            background: #5a321e;
            position: relative;
        }
        
        #chessboard::before {
            content: "";
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border: 5px solid #b08d57;
            border-radius: 10px;
            pointer-events: none;
            z-index: -1;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 250px;
        }
        
        .status {
            background: rgba(90, 50, 30, 0.8);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            font-size: 1.3rem;
            border: 2px solid #b08d57;
            color: #e8d0b3;
        }
        
        .buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        button {
            padding: 14px;
            background: linear-gradient(to bottom, #8b5a2b, #6b4f37);
            color: #f5e8c8;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            font-family: 'Georgia', serif;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            border: 1px solid #b08d57;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #9b6a3b, #7b5f47);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        
        .game-info {
            background: rgba(90, 50, 30, 0.8);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 100%;
            margin-top: 10px;
            border: 2px solid #b08d57;
        }
        
        .game-info h3 {
            margin-top: 0;
            border-bottom: 2px solid #b08d57;
            padding-bottom: 10px;
            color: #e8d0b3;
            font-size: 1.4rem;
            text-align: center;
        }
        
        .move-history {
            max-height: 150px;
            overflow-y: auto;
            padding: 15px;
            background: rgba(60, 30, 15, 0.6);
            border-radius: 5px;
            font-family: 'Georgia', serif;
            border: 1px solid #b08d57;
        }
        
        .move-history div {
            padding: 5px 10px;
            border-bottom: 1px solid #b08d57;
            color: #e8d0b3;
        }
        
        .move-history div:last-child {
            border-bottom: none;
        }
        
        .rules {
            background: rgba(90, 50, 30, 0.8);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #b08d57;
        }
        
        .rules ul {
            padding-left: 20px;
            color: #e8d0b3;
        }
        
        .rules li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        /* 滚动条样式 */
        .move-history::-webkit-scrollbar {
            width: 8px;
        }
        
        .move-history::-webkit-scrollbar-track {
            background: rgba(60, 30, 15, 0.6);
            border-radius: 4px;
        }
        
        .move-history::-webkit-scrollbar-thumb {
            background: #b08d57;
            border-radius: 4px;
        }
        
        .move-history::-webkit-scrollbar-thumb:hover {
            background: #d4b896;
        }
        
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            #chessboard {
                width: 90vw;
                height: 90vw;
            }
            
            .controls {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1>复古国际象棋</h1>
            <p>体验经典的国际象棋对局</p>
        </div>
        
        <div class="game-area">
            <canvas id="chessboard" width="560" height="560"></canvas>
            
            <div class="controls">
                <div class="status" id="game-status">
                    轮到白方走棋
                </div>
                
                <div class="buttons">
                    <button id="undo-btn">悔棋</button>
                    <button id="new-game-btn">新游戏</button>
                    <button id="ai-move-btn">AI走棋</button>
                </div>
                
                <div class="rules">
                    <h3>特殊规则</h3>
                    <ul>
                        <li><strong>王车易位：</strong>王向车移动两格，车越过王</li>
                        <li><strong>吃过路兵：</strong>兵可以斜吃敌方刚移动两格的兵</li>
                        <li><strong>兵升变：</strong>兵到达底线可升变为后、车、马或象</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="game-info">
            <h3>走子记录</h3>
            <div class="move-history" id="move-history"></div>
        </div>
    </div>

    <script>
        // 棋盘和游戏状态
        const canvas = document.getElementById('chessboard');
        const ctx = canvas.getContext('2d');
        const boardSize = 8;
        const squareSize = canvas.width / boardSize;
        
        // 棋子Unicode字符
        const pieces = {
            'wp': '♙', 'wr': '♖', 'wn': '♘', 'wb': '♗', 'wq': '♕', 'wk': '♔',
            'bp': '♟', 'br': '♜', 'bn': '♞', 'bb': '♝', 'bq': '♛', 'bk': '♚'
        };
        
        // 初始棋盘布局
        let board = [
            ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
            ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
            ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
        ];
        
        // 游戏状态
        let currentPlayer = 'w'; // 'w' 或 'b'
        let selectedPiece = null;
        let validMoves = [];
        let gameHistory = [];
        let moveHistory = [];
        let kings = { 'w': [7, 4], 'b': [0, 4] }; // 王的位置
        let enPassantTarget = null; // 吃过路兵目标位置
        let castlingRights = { 'w': { kingside: true, queenside: true }, 'b': { kingside: true, queenside: true } };
        let gameOver = false;
        
        // 绘制棋盘
        function drawBoard() {
            // 绘制棋盘底色 - 深棕色
            ctx.fillStyle = '#5a321e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制棋盘格子 - 复古米色和深棕色
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if ((row + col) % 2 === 1) {
                        ctx.fillStyle = '#d4b896'; // 米色格子
                    } else {
                        ctx.fillStyle = '#8b5a2b'; // 深棕色格子
                    }
                    ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                    
                    // 为格子添加纹理效果
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                }
            }
            
            // 绘制选中格子和有效移动
            if (selectedPiece) {
                const [row, col] = selectedPiece;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                
                // 绘制有效移动
                validMoves.forEach(([r, c]) => {
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.4)';
                    ctx.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);
                    
                    // 绘制移动指示点
                    ctx.fillStyle = 'rgba(50, 205, 50, 0.7)';
                    ctx.beginPath();
                    ctx.arc(
                        c * squareSize + squareSize / 2,
                        r * squareSize + squareSize / 2,
                        squareSize / 6,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
            
            // 绘制棋子
            ctx.font = `bold ${squareSize * 0.7}px Georgia`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        // 为棋子添加阴影效果
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        ctx.fillStyle = piece[0] === 'w' ? '#f8f8f8' : '#2c1810';
                        ctx.fillText(
                            pieces[piece],
                            col * squareSize + squareSize / 2,
                            row * squareSize + squareSize / 2
                        );
                        
                        // 重置阴影
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                }
            }
            
            // 绘制棋盘边框装饰
            ctx.strokeStyle = '#b08d57';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // 绘制内部装饰线
            ctx.strokeStyle = 'rgba(176, 141, 87, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * squareSize, 0);
                ctx.lineTo(i * squareSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * squareSize);
                ctx.lineTo(canvas.width, i * squareSize);
                ctx.stroke();
            }
        }
        
        // 获取鼠标点击的棋盘位置
        function getBoardPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const boardX = x - rect.left;
            const boardY = y - rect.top;
            
            const col = Math.floor(boardX / squareSize);
            const row = Math.floor(boardY / squareSize);
            
            return [row, col];
        }
        
        // 检查位置是否在棋盘内
        function isValidPosition(row, col) {
            return row >= 0 && row < boardSize && col >= 0 && col < boardSize;
        }
        
        // 获取棋子所有可能移动
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece || piece[0] !== currentPlayer) return [];
            
            const pieceType = piece[1];
            const moves = [];
            
            switch (pieceType) {
                case 'p': // 兵
                    const direction = piece[0] === 'w' ? -1 : 1;
                    const startRow = piece[0] === 'w' ? 6 : 1;
                    
                    // 向前移动一格
                    if (isValidPosition(row + direction, col) && !board[row + direction][col]) {
                        moves.push([row + direction, col]);
                        
                        // 向前移动两格（起始位置）
                        if (row === startRow && !board[row + 2 * direction][col]) {
                            moves.push([row + 2 * direction, col]);
                        }
                    }
                    
                    // 吃子（包括吃过路兵）
                    for (const dc of [-1, 1]) {
                        if (isValidPosition(row + direction, col + dc)) {
                            const target = board[row + direction][col + dc];
                            if (target && target[0] !== piece[0]) {
                                moves.push([row + direction, col + dc]);
                            }
                            
                            // 吃过路兵
                            if (enPassantTarget && enPassantTarget[0] === row + direction && enPassantTarget[1] === col + dc) {
                                moves.push([row + direction, col + dc]);
                            }
                        }
                    }
                    break;
                    
                case 'r': // 车
                    addLinearMoves(row, col, [[-1, 0], [1, 0], [0, -1], [0, 1]], moves);
                    break;
                    
                case 'n': // 马
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    addJumpMoves(row, col, knightMoves, moves);
                    break;
                    
                case 'b': // 象
                    addLinearMoves(row, col, [[-1, -1], [-1, 1], [1, -1], [1, 1]], moves);
                    break;
                    
                case 'q': // 后
                    addLinearMoves(row, col, [
                        [-1, 0], [1, 0], [0, -1], [0, 1],
                        [-1, -1], [-1, 1], [1, -1], [1, 1]
                    ], moves);
                    break;
                    
                case 'k': // 王
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1],
                        [0, -1], [0, 1],
                        [1, -1], [1, 0], [1, 1]
                    ];
                    addJumpMoves(row, col, kingMoves, moves);
                    
                    // 王车易位
                    if (row === kings[currentPlayer][0] && col === kings[currentPlayer][1]) {
                        // 短易位（王翼易位）
                        if (castlingRights[currentPlayer].kingside && 
                            !board[row][col+1] && !board[row][col+2] &&
                            !isSquareAttacked(row, col, currentPlayer) &&
                            !isSquareAttacked(row, col+1, currentPlayer) &&
                            !isSquareAttacked(row, col+2, currentPlayer)) {
                            moves.push([row, col+2]);
                        }
                        
                        // 长易位（后翼易位）
                        if (castlingRights[currentPlayer].queenside && 
                            !board[row][col-1] && !board[row][col-2] && !board[row][col-3] &&
                            !isSquareAttacked(row, col, currentPlayer) &&
                            !isSquareAttacked(row, col-1, currentPlayer) &&
                            !isSquareAttacked(row, col-2, currentPlayer)) {
                            moves.push([row, col-2]);
                        }
                    }
                    break;
            }
            
            // 过滤掉会导致自己被将军的移动
            return moves.filter(move => {
                const [newRow, newCol] = move;
                const capturedPiece = board[newRow][newCol];
                
                // 临时执行移动
                board[newRow][newCol] = piece;
                board[row][col] = '';
                
                // 更新王的位置
                let kingRow = kings[currentPlayer][0];
                let kingCol = kings[currentPlayer][1];
                if (piece[1] === 'k') {
                    kingRow = newRow;
                    kingCol = newCol;
                }
                
                // 检查是否被将军
                const inCheck = isSquareAttacked(kingRow, kingCol, currentPlayer);
                
                // 撤销移动
                board[row][col] = piece;
                board[newRow][newCol] = capturedPiece;
                
                return !inCheck;
            });
        }
        
        // 添加线性移动（车、后、象）
        function addLinearMoves(row, col, directions, moves) {
            const piece = board[row][col];
            
            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                
                while (isValidPosition(r, c)) {
                    if (!board[r][c]) {
                        moves.push([r, c]);
                    } else {
                        if (board[r][c][0] !== piece[0]) {
                            moves.push([r, c]);
                        }
                        break;
                    }
                    
                    r += dr;
                    c += dc;
                }
            }
        }
        
        // 添加跳跃移动（马、王）
        function addJumpMoves(row, col, jumps, moves) {
            const piece = board[row][col];
            
            for (const [dr, dc] of jumps) {
                const r = row + dr;
                const c = col + dc;
                
                if (isValidPosition(r, c) && (!board[r][c] || board[r][c][0] !== piece[0])) {
                    moves.push([r, c]);
                }
            }
        }
        
        // 检查某个位置是否被攻击
        function isSquareAttacked(row, col, color) {
            const opponent = color === 'w' ? 'b' : 'w';
            
            // 检查兵的攻击
            const pawnDirection = color === 'w' ? 1 : -1;
            for (const dc of [-1, 1]) {
                const r = row + pawnDirection;
                const c = col + dc;
                if (isValidPosition(r, c) && board[r][c] === `${opponent}p`) {
                    return true;
                }
            }
            
            // 检查马的攻击
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (const [dr, dc] of knightMoves) {
                const r = row + dr;
                const c = col + dc;
                if (isValidPosition(r, c) && board[r][c] === `${opponent}n`) {
                    return true;
                }
            }
            
            // 检查直线攻击（车、后）
            const straightDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of straightDirections) {
                let r = row + dr;
                let c = col + dc;
                
                while (isValidPosition(r, c)) {
                    if (board[r][c]) {
                        if (board[r][c][0] === opponent && 
                            (board[r][c][1] === 'r' || board[r][c][1] === 'q')) {
                            return true;
                        }
                        break;
                    }
                    
                    r += dr;
                    c += dc;
                }
            }
            
            // 检查斜线攻击（象、后）
            const diagonalDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (const [dr, dc] of diagonalDirections) {
                let r = row + dr;
                let c = col + dc;
                
                while (isValidPosition(r, c)) {
                    if (board[r][c]) {
                        if (board[r][c][0] === opponent && 
                            (board[r][c][1] === 'b' || board[r][c][1] === 'q')) {
                            return true;
                        }
                        break;
                    }
                    
                    r += dr;
                    c += dc;
                }
            }
            
            // 检查王的攻击
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            for (const [dr, dc] of kingMoves) {
                const r = row + dr;
                const c = col + dc;
                if (isValidPosition(r, c) && board[r][c] === `${opponent}k`) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 执行移动
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // 保存游戏状态用于悔棋
            gameHistory.push({
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer: currentPlayer,
                kings: {...kings},
                enPassantTarget: enPassantTarget,
                castlingRights: JSON.parse(JSON.stringify(castlingRights))
            });
            
            // 执行移动
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            
            // 更新王的位置
            if (piece[1] === 'k') {
                kings[piece[0]] = [toRow, toCol];
                
                // 更新易位权限
                castlingRights[piece[0]].kingside = false;
                castlingRights[piece[0]].queenside = false;
                
                // 王车易位
                if (Math.abs(toCol - fromCol) === 2) {
                    if (toCol > fromCol) { // 短易位
                        board[toRow][toCol-1] = board[toRow][7];
                        board[toRow][7] = '';
                    } else { // 长易位
                        board[toRow][toCol+1] = board[toRow][0];
                        board[toRow][0] = '';
                    }
                }
            }
            
            // 更新车移动后的易位权限
            if (piece[1] === 'r') {
                if (fromRow === 0 && fromCol === 0) castlingRights.b.queenside = false;
                if (fromRow === 0 && fromCol === 7) castlingRights.b.kingside = false;
                if (fromRow === 7 && fromCol === 0) castlingRights.w.queenside = false;
                if (fromRow === 7 && fromCol === 7) castlingRights.w.kingside = false;
            }
            
            // 吃过路兵
            if (piece[1] === 'p' && enPassantTarget && toRow === enPassantTarget[0] && toCol === enPassantTarget[1]) {
                const captureRow = piece[0] === 'w' ? toRow + 1 : toRow - 1;
                board[captureRow][toCol] = '';
            }
            
            // 设置吃过路兵目标
            enPassantTarget = null;
            if (piece[1] === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = [fromRow + (toRow - fromRow) / 2, fromCol];
            }
            
            // 兵升变
            if (piece[1] === 'p' && (toRow === 0 || toRow === 7)) {
                // 默认升变为后
                board[toRow][toCol] = piece[0] + 'q';
            }
            
            // 记录走子
            const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
            const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
            moveHistory.push(`${currentPlayer === 'w' ? '白方' : '黑方'}: ${fromSquare} → ${toSquare}`);
            updateMoveHistory();
            
            // 切换玩家
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            
            // 检查游戏状态
            checkGameState();
        }
        
        // 检查游戏状态（将军、将死等）
        function checkGameState() {
            const kingRow = kings[currentPlayer][0];
            const kingCol = kings[currentPlayer][1];
            
            // 检查是否被将军
            const inCheck = isSquareAttacked(kingRow, kingCol, currentPlayer);
            
            // 检查是否有合法移动
            let hasLegalMoves = false;
            for (let row = 0; row < boardSize && !hasLegalMoves; row++) {
                for (let col = 0; col < boardSize && !hasLegalMoves; col++) {
                    const piece = board[row][col];
                    if (piece && piece[0] === currentPlayer) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            hasLegalMoves = true;
                        }
                    }
                }
            }
            
            // 更新游戏状态显示
            const statusElement = document.getElementById('game-status');
            if (!hasLegalMoves) {
                if (inCheck) {
                    statusElement.textContent = `${currentPlayer === 'w' ? '黑方' : '白方'} 将死！游戏结束`;
                    statusElement.style.color = '#ff6b6b';
                    gameOver = true;
                } else {
                    statusElement.textContent = "僵局！游戏结束";
                    statusElement.style.color = '#ffa500';
                    gameOver = true;
                }
            } else if (inCheck) {
                statusElement.textContent = `${currentPlayer === 'w' ? '白方' : '黑方'} 被将军`;
                statusElement.style.color = '#ffa500';
            } else {
                statusElement.textContent = `轮到${currentPlayer === 'w' ? '白方' : '黑方'}走棋`;
                statusElement.style.color = '#e8d0b3';
            }
        }
        
        // 更新走子记录显示
        function updateMoveHistory() {
            const historyElement = document.getElementById('move-history');
            historyElement.innerHTML = '';
            
            moveHistory.forEach(move => {
                const moveElement = document.createElement('div');
                moveElement.textContent = move;
                historyElement.appendChild(moveElement);
            });
            
            historyElement.scrollTop = historyElement.scrollHeight;
        }
        
        // 悔棋功能
        function undoMove() {
            if (gameHistory.length === 0 || gameOver) return;
            
            const lastState = gameHistory.pop();
            board = lastState.board;
            currentPlayer = lastState.currentPlayer;
            kings = lastState.kings;
            enPassantTarget = lastState.enPassantTarget;
            castlingRights = lastState.castlingRights;
            
            moveHistory.pop();
            updateMoveHistory();
            
            selectedPiece = null;
            validMoves = [];
            gameOver = false;
            
            const statusElement = document.getElementById('game-status');
            statusElement.textContent = `轮到${currentPlayer === 'w' ? '白方' : '黑方'}走棋`;
            statusElement.style.color = '#e8d0b3';
            
            drawBoard();
        }
        
        // AI走棋（简单随机移动）
        function makeAIMove() {
            if (currentPlayer !== 'b' || gameOver) return;
            
            // 收集所有可能的移动
            const allMoves = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const piece = board[row][col];
                    if (piece && piece[0] === 'b') {
                        const moves = getValidMoves(row, col);
                        moves.forEach(move => {
                            allMoves.push({ from: [row, col], to: move });
                        });
                    }
                }
            }
            
            // 随机选择一个移动
            if (allMoves.length > 0) {
                const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                makeMove(randomMove.from[0], randomMove.from[1], randomMove.to[0], randomMove.to[1]);
                drawBoard();
            }
        }
        
        // 新游戏
        function newGame() {
            board = [
                ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
                ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
            ];
            
            currentPlayer = 'w';
            selectedPiece = null;
            validMoves = [];
            gameHistory = [];
            moveHistory = [];
            kings = { 'w': [7, 4], 'b': [0, 4] };
            enPassantTarget = null;
            castlingRights = { 'w': { kingside: true, queenside: true }, 'b': { kingside: true, queenside: true } };
            gameOver = false;
            
            const statusElement = document.getElementById('game-status');
            statusElement.textContent = "轮到白方走棋";
            statusElement.style.color = '#e8d0b3';
            
            updateMoveHistory();
            drawBoard();
        }
        
        // 初始化游戏
        function init() {
            drawBoard();
            
            // 添加棋盘点击事件
            canvas.addEventListener('click', (e) => {
                if (gameOver) return;
                
                const [row, col] = getBoardPosition(e.clientX, e.clientY);
                
                // 如果已经选中了一个棋子
                if (selectedPiece) {
                    const [selectedRow, selectedCol] = selectedPiece;
                    
                    // 检查是否点击了有效移动
                    const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
                    
                    if (isValidMove) {
                        makeMove(selectedRow, selectedCol, row, col);
                        drawBoard();
                    }
                    
                    // 重置选择
                    selectedPiece = null;
                    validMoves = [];
                    
                    // 如果点击了另一个己方棋子，选择它
                    if (board[row][col] && board[row][col][0] === currentPlayer) {
                        selectedPiece = [row, col];
                        validMoves = getValidMoves(row, col);
                        drawBoard();
                    }
                } else {
                    // 选择棋子
                    if (board[row][col] && board[row][col][0] === currentPlayer) {
                        selectedPiece = [row, col];
                        validMoves = getValidMoves(row, col);
                        drawBoard();
                    }
                }
            });
            
            // 添加按钮事件
            document.getElementById('undo-btn').addEventListener('click', undoMove);
            document.getElementById('new-game-btn').addEventListener('click', newGame);
            document.getElementById('ai-move-btn').addEventListener('click', makeAIMove);
        }
        
        // 启动游戏
        init();
    </script>
</body>
</html>
